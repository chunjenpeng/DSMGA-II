
=======================================================================

2016-03-09

TODO : try ./DSMGA2 10 50 1 -1 -1 1 1 -1 to verify correctness of  findMask

=======================================================================

2016-03-09
1. modify trimatrix.h 
	T** matrix <p00p11linkage, p01p10linkage>

2. replace DSMGA2::findClique with DSMGA2::findMask

3. DSMGA2::findMask is used to find mask right before RM
   	it checks if two adjacent nodes are 00,11 or 01,10 
	before choosing the linkage00 or linkage01 to use to build the graph
	However... something is not right in the code
	Need verification...

=======================================================================
2016-03-04

1. T** matrix <p00p11linkage, p01p10linkage>
2. How to compute MI?
3. LCS, GP(GECCO GP track), Grammer!
4. OM fundemental Theory(Supply vs. (average) Dimension of Node(e.g. NK d = 2))
  	  step-by-step: tree graph, cyclic graph, cyclic graph with edges
	  volumn-surface ratio?


TODO: 1.Confirm how to compute MI
      
	  (V)2.What to do with 2 edges? add restrictions in RM s.t. only take if satisfy posOrNegLinkage?    
           (build 2-edges graph first, then check for pos or neg edge while RM to decide which mask to take)
	  (V)3.How to implement? 
	  	 3.1 T*** matrix
		    (Better with T**<posEdge, negEdge>)

		 3.2 save p00, p11 with positive linkage value
		         p01, p10 with negative linkage value
			findClique(int startNode, list<int>& masks[i]) with abs(linkage)
			save list<int>& result as negative node number for p01, p10
            (Not how prof was imagining...)

=======================================================================

2016-03-03

1. print improved fitenss after RM, takenMask during RM and trial, ch
2. MI(p00, p11) = computeMI(p01+p10, p00, p11, 0.0)
   MI(p01, p10) = computeMI(p00+p11, p01, p10, 0.0)

   I thought MI(p00, p11) + MI(p01, p10) = MI(p00, p01, p10, p11)
   but it didn't work with ./sweep 10 1 2...
   Need to confirm how to compute MI

3. Tried to modify trimatrix.h by adding bool** edge
                                         write(i, j, linkage, bool posOrNegLinkage)
										   {update edge[i-1][j] = posOrNegLinkage;}
   but end up with segmentation fault...
   Need a better plan to record posOrNegLinkage and also How to use it

=======================================================================

2016-03-01

TODO: 1. trimatrix.h:89 T*** matrix (i, j, edge)
      2. modify trimatrix.h for T*** matrix
	  3. (Solved: takenMask in RM)find where to print ILS
	  4. compare ILS before and after 2-edge graph modification

1. Print graph in DSMGA2::mixing()
2. Print takenMask in DSMGA2::restrictedMixing(Chromosome& ch, list<int>& mask)

=======================================================================

2016-02-28

1.Start with dsmga2.cpp:461 findClique

2.In dsmga2.cpp:425 buildGraph:
	origianl linkage = computeMI(p00, p01, p10, p11);
	     add linkage0 = computeMI(p00, 0.0, 0.0, p11);
	         linkage1 = computeMI(p00, 0.0, 0.0, p11);
			 doesn't seemed to be better...
			 why linkage0 + linkage1 > linkage ?
			 shouldn't MI be linkage0 + linkage1 == linkage?

   Problem: What is the Meaning of MI in 2-edges graph?

3. Found that sweep is already included... =_="
	    

=======================================================================

2016-02-27

1. Setup local, Github repositories: master(origianl DSMGA2) & 2-edges branche

=======================================================================
